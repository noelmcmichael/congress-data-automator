#!/usr/bin/env python3
"""
Phase B: 815 Committee SQL Deployment Generator
==============================================

Generate optimized SQL deployment script for 440 new committees.
Uses proven patterns from previous successful deployments.
"""

import json
import re
from datetime import datetime
from typing import Dict, List, Any

class PhaseBSQLGenerator:
    """Generate production-ready SQL for 815 committee deployment"""
    
    def __init__(self, data_file: str):
        self.data_file = data_file
        self.committees_data = None
        self.sql_statements = []
        self.batch_size = 50  # Proven optimal batch size
        
        self.generation_log = []
        self.log_event("Initialized Phase B SQL Generator")
    
    def log_event(self, message: str, level: str = "info"):
        """Log generation events with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {level.upper()}: {message}"
        self.generation_log.append(log_entry)
        print(log_entry)
    
    def load_committee_data(self) -> bool:
        """Load generated committee data"""
        self.log_event(f"Loading committee data from {self.data_file}")
        
        try:
            with open(self.data_file, 'r') as f:
                self.committees_data = json.load(f)
            
            generated_count = len(self.committees_data['generated_committees'])
            self.log_event(f"Loaded {generated_count} committees for SQL generation", "success")
            return True
            
        except Exception as e:
            self.log_event(f"Failed to load committee data: {e}", "error")
            return False
    
    def escape_sql_value(self, value: str) -> str:
        """Escape SQL string values to prevent injection and handle special characters"""
        if value is None:
            return 'NULL'
        
        # Handle apostrophes and quotes
        escaped = value.replace("'", "''")
        escaped = escaped.replace('"', '""')
        
        return f"'{escaped}'"
    
    def generate_insert_statement(self, committee: Dict[str, Any]) -> str:
        """Generate SQL INSERT statement for a single committee"""
        # Extract values with defaults
        congress_gov_id = committee.get('congress_gov_id', '')
        name = committee.get('name', '')
        chamber = committee.get('chamber', '')
        committee_type = committee.get('committee_type', 'Standing')
        parent_committee_code = committee.get('parent_committee_code')
        
        # Escape values
        escaped_id = self.escape_sql_value(congress_gov_id)
        escaped_name = self.escape_sql_value(name)
        escaped_chamber = self.escape_sql_value(chamber)
        escaped_type = self.escape_sql_value(committee_type)
        escaped_parent = self.escape_sql_value(parent_committee_code) if parent_committee_code else 'NULL'
        
        # Generate INSERT statement
        sql = f"""INSERT INTO committees (congress_gov_id, name, chamber, committee_type, parent_committee_code) 
VALUES ({escaped_id}, {escaped_name}, {escaped_chamber}, {escaped_type}, {escaped_parent})
ON CONFLICT (congress_gov_id) DO NOTHING;"""
        
        return sql
    
    def generate_batch_sql(self, committees: List[Dict], batch_number: int) -> str:
        """Generate SQL for a batch of committees"""
        self.log_event(f"Generating SQL for batch {batch_number} ({len(committees)} committees)")
        
        sql_lines = [
            f"-- Batch {batch_number}: {len(committees)} committees",
            "-- Generated by Phase B SQL Generator",
            f"-- Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            ""
        ]
        
        for committee in committees:
            insert_sql = self.generate_insert_statement(committee)
            sql_lines.append(insert_sql)
            sql_lines.append("")  # Empty line for readability
        
        return "\n".join(sql_lines)
    
    def generate_deployment_sql(self) -> bool:
        """Generate complete deployment SQL with batching"""
        if not self.committees_data:
            self.log_event("No committee data loaded", "error")
            return False
        
        committees = self.committees_data['generated_committees']
        total_committees = len(committees)
        
        self.log_event(f"Generating SQL for {total_committees} committees in batches of {self.batch_size}")
        
        # SQL header
        header_sql = f"""-- 815 Committee Expansion Deployment SQL
-- Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-- Total committees: {total_committees}
-- Batch size: {self.batch_size}
-- Target total: 815 committees (375 existing + 440 new)

-- Enable autocommit for better transaction handling
SET autocommit = true;

-- Validate schema before deployment
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'committees') THEN
        RAISE EXCEPTION 'Table committees does not exist';
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'committees' AND column_name = 'congress_gov_id') THEN
        RAISE EXCEPTION 'Column congress_gov_id does not exist';
    END IF;
END $$;

-- Begin deployment
"""
        
        self.sql_statements.append(header_sql)
        
        # Generate batched SQL
        batch_number = 1
        for i in range(0, total_committees, self.batch_size):
            batch_committees = committees[i:i + self.batch_size]
            batch_sql = self.generate_batch_sql(batch_committees, batch_number)
            self.sql_statements.append(batch_sql)
            batch_number += 1
        
        # SQL footer with validation
        footer_sql = f"""
-- Deployment validation
DO $$
DECLARE
    committee_count INTEGER;
    expected_count INTEGER := 815;
BEGIN
    SELECT COUNT(*) INTO committee_count FROM committees;
    
    RAISE NOTICE 'Deployment validation:';
    RAISE NOTICE '  Total committees in database: %', committee_count;
    RAISE NOTICE '  Expected total: %', expected_count;
    
    IF committee_count = expected_count THEN
        RAISE NOTICE '  STATUS: SUCCESS - Exact target achieved!';
    ELSIF committee_count > expected_count THEN
        RAISE NOTICE '  STATUS: WARNING - More committees than expected';
    ELSE
        RAISE NOTICE '  STATUS: WARNING - Fewer committees than expected';
    END IF;
END $$;

-- Final statistics
SELECT 
    chamber,
    committee_type,
    COUNT(*) as count
FROM committees 
WHERE congress_gov_id IS NOT NULL
GROUP BY chamber, committee_type
ORDER BY chamber, committee_type;

-- Completion timestamp
SELECT 'Deployment completed at: ' || NOW()::text as deployment_status;
"""
        
        self.sql_statements.append(footer_sql)
        
        total_batches = len(self.sql_statements) - 2  # Exclude header and footer
        self.log_event(f"Generated SQL in {total_batches} batches", "success")
        return True
    
    def save_sql_file(self) -> str:
        """Save generated SQL to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"815_committee_deployment_{timestamp}.sql"
        
        # Combine all SQL statements
        complete_sql = "\n".join(self.sql_statements)
        
        with open(filename, 'w') as f:
            f.write(complete_sql)
        
        file_size = len(complete_sql)
        self.log_event(f"SQL saved to {filename} ({file_size:,} characters)", "success")
        return filename
    
    def generate_deployment_summary(self) -> Dict[str, Any]:
        """Generate deployment summary"""
        if not self.committees_data:
            return {}
        
        committees = self.committees_data['generated_committees']
        
        chamber_distribution = {
            'House': len([c for c in committees if c['chamber'] == 'House']),
            'Senate': len([c for c in committees if c['chamber'] == 'Senate']),
            'Joint': len([c for c in committees if c['chamber'] == 'Joint'])
        }
        
        type_distribution = {
            'Standing': len([c for c in committees if c['committee_type'] == 'Standing']),
            'Subcommittee': len([c for c in committees if c['committee_type'] == 'Subcommittee']),
            'Joint': len([c for c in committees if c['committee_type'] == 'Joint'])
        }
        
        # Count committees with parent relationships
        with_parents = len([c for c in committees if c.get('parent_committee_code')])
        
        return {
            'generation_timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'total_committees': len(committees),
            'target_total': 815,
            'existing_committees': 375,
            'batch_size': self.batch_size,
            'total_batches': len(self.sql_statements) - 2,
            'chamber_distribution': chamber_distribution,
            'type_distribution': type_distribution,
            'committees_with_parents': with_parents,
            'sql_size_characters': len("\n".join(self.sql_statements)),
            'validation': {
                'all_have_codes': all(c.get('congress_gov_id') for c in committees),
                'all_have_names': all(c.get('name') for c in committees),
                'all_have_chambers': all(c.get('chamber') for c in committees),
                'all_have_types': all(c.get('committee_type') for c in committees)
            }
        }

def main():
    """Main execution function"""
    print("=== Phase B: 815 Committee SQL Generator ===")
    
    # Find the most recent data file
    import glob
    data_files = glob.glob("aggressive_815_expansion_*.json")
    if not data_files:
        print("ERROR: No expansion data file found. Please run the generator first.")
        return False
    
    latest_file = sorted(data_files)[-1]
    print(f"Using data file: {latest_file}")
    print("=" * 50)
    
    generator = PhaseBSQLGenerator(latest_file)
    
    if not generator.load_committee_data():
        return False
    
    if not generator.generate_deployment_sql():
        return False
    
    sql_file = generator.save_sql_file()
    summary = generator.generate_deployment_summary()
    
    # Save summary
    summary_file = f"815_deployment_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(summary_file, 'w') as f:
        json.dump(summary, f, indent=2)
    
    print("\n" + "=" * 50)
    print("PHASE B SQL GENERATION COMPLETE!")
    print(f"SQL file: {sql_file}")
    print(f"Summary file: {summary_file}")
    print(f"Total committees: {summary['total_committees']}")
    print(f"SQL size: {summary['sql_size_characters']:,} characters")
    print(f"Batches: {summary['total_batches']}")
    print("Chamber distribution:", summary['chamber_distribution'])
    print("Type distribution:", summary['type_distribution'])
    print("=" * 50)
    
    return True

if __name__ == "__main__":
    main()