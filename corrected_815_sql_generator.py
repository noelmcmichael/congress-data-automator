#!/usr/bin/env python3
"""
Corrected 815 Committee SQL Generator
===================================

Generate SQL that matches the actual database schema.
"""

import json
import re
from datetime import datetime
from typing import Dict, List, Any

class CorrectedSQLGenerator:
    """Generate SQL matching actual database schema"""
    
    def __init__(self, data_file: str):
        self.data_file = data_file
        self.committees_data = None
        self.sql_statements = []
        self.batch_size = 50
        
        self.generation_log = []
        self.log_event("Initialized Corrected SQL Generator")
    
    def log_event(self, message: str, level: str = "info"):
        """Log generation events with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {level.upper()}: {message}"
        self.generation_log.append(log_entry)
        print(log_entry)
    
    def load_committee_data(self) -> bool:
        """Load generated committee data"""
        self.log_event(f"Loading committee data from {self.data_file}")
        
        try:
            with open(self.data_file, 'r') as f:
                self.committees_data = json.load(f)
            
            generated_count = len(self.committees_data['generated_committees'])
            self.log_event(f"Loaded {generated_count} committees for SQL generation", "success")
            return True
            
        except Exception as e:
            self.log_event(f"Failed to load committee data: {e}", "error")
            return False
    
    def escape_sql_value(self, value: str) -> str:
        """Escape SQL string values"""
        if value is None:
            return 'NULL'
        
        # Handle apostrophes and quotes
        escaped = value.replace("'", "''")
        escaped = escaped.replace('"', '""')
        
        return f"'{escaped}'"
    
    def generate_insert_statement(self, committee: Dict[str, Any]) -> str:
        """Generate SQL INSERT statement matching actual schema"""
        # Extract values with defaults
        congress_gov_id = committee.get('congress_gov_id', '')
        committee_code = committee.get('congress_gov_id', '')  # Use same as gov_id
        name = committee.get('name', '')
        chamber = committee.get('chamber', '')
        committee_type = committee.get('committee_type', 'Standing')
        is_subcommittee = committee.get('committee_type') == 'Subcommittee'
        
        # Escape values
        escaped_id = self.escape_sql_value(congress_gov_id)
        escaped_code = self.escape_sql_value(committee_code)
        escaped_name = self.escape_sql_value(name)
        escaped_chamber = self.escape_sql_value(chamber)
        escaped_type = self.escape_sql_value(committee_type)
        
        # Generate INSERT statement with actual schema
        sql = f"""INSERT INTO committees (
    congress_gov_id, 
    committee_code, 
    name, 
    chamber, 
    committee_type, 
    is_subcommittee,
    is_active,
    congress_session,
    created_at,
    updated_at
) VALUES (
    {escaped_id}, 
    {escaped_code}, 
    {escaped_name}, 
    {escaped_chamber}, 
    {escaped_type}, 
    {is_subcommittee},
    true,
    119,
    NOW(),
    NOW()
) ON CONFLICT (congress_gov_id) DO NOTHING;"""
        
        return sql
    
    def generate_batch_sql(self, committees: List[Dict], batch_number: int) -> str:
        """Generate SQL for a batch of committees"""
        self.log_event(f"Generating SQL for batch {batch_number} ({len(committees)} committees)")
        
        sql_lines = [
            f"-- Batch {batch_number}: {len(committees)} committees",
            "-- Generated by Corrected SQL Generator",
            f"-- Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            ""
        ]
        
        for committee in committees:
            insert_sql = self.generate_insert_statement(committee)
            sql_lines.append(insert_sql)
            sql_lines.append("")  # Empty line for readability
        
        return "\n".join(sql_lines)
    
    def generate_deployment_sql(self) -> bool:
        """Generate complete deployment SQL"""
        if not self.committees_data:
            self.log_event("No committee data loaded", "error")
            return False
        
        committees = self.committees_data['generated_committees']
        total_committees = len(committees)
        
        self.log_event(f"Generating corrected SQL for {total_committees} committees")
        
        # SQL header
        header_sql = f"""-- 815 Committee Expansion Deployment SQL (Corrected)
-- Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-- Total committees: {total_committees}
-- Batch size: {self.batch_size}
-- Target total: 815 committees (375 existing + 440 new)

-- Validate schema before deployment
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'committees') THEN
        RAISE EXCEPTION 'Table committees does not exist';
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'committees' AND column_name = 'congress_gov_id') THEN
        RAISE EXCEPTION 'Column congress_gov_id does not exist';
    END IF;
    
    RAISE NOTICE 'Schema validation passed - starting deployment...';
END $$;

-- Begin deployment
"""
        
        self.sql_statements.append(header_sql)
        
        # Generate batched SQL
        batch_number = 1
        for i in range(0, total_committees, self.batch_size):
            batch_committees = committees[i:i + self.batch_size]
            batch_sql = self.generate_batch_sql(batch_committees, batch_number)
            self.sql_statements.append(batch_sql)
            batch_number += 1
        
        # SQL footer with validation
        footer_sql = f"""
-- Deployment validation
DO $$
DECLARE
    committee_count INTEGER;
    expected_count INTEGER := 815;
BEGIN
    SELECT COUNT(*) INTO committee_count FROM committees;
    
    RAISE NOTICE 'Deployment validation:';
    RAISE NOTICE '  Total committees in database: %', committee_count;
    RAISE NOTICE '  Expected total: %', expected_count;
    
    IF committee_count = expected_count THEN
        RAISE NOTICE '  STATUS: SUCCESS - Exact target achieved!';
    ELSIF committee_count > expected_count THEN
        RAISE NOTICE '  STATUS: WARNING - More committees than expected';
    ELSE
        RAISE NOTICE '  STATUS: WARNING - Fewer committees than expected';
    END IF;
END $$;

-- Final statistics
SELECT 
    chamber,
    committee_type,
    COUNT(*) as count
FROM committees 
WHERE congress_gov_id IS NOT NULL
GROUP BY chamber, committee_type
ORDER BY chamber, committee_type;

-- Completion timestamp
SELECT 'Deployment completed at: ' || NOW()::text as deployment_status;
"""
        
        self.sql_statements.append(footer_sql)
        
        total_batches = len(self.sql_statements) - 2
        self.log_event(f"Generated corrected SQL in {total_batches} batches", "success")
        return True
    
    def save_sql_file(self) -> str:
        """Save generated SQL to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"815_committee_deployment_corrected_{timestamp}.sql"
        
        # Combine all SQL statements
        complete_sql = "\n".join(self.sql_statements)
        
        with open(filename, 'w') as f:
            f.write(complete_sql)
        
        file_size = len(complete_sql)
        self.log_event(f"Corrected SQL saved to {filename} ({file_size:,} characters)", "success")
        return filename

def main():
    """Main execution function"""
    print("=== Corrected 815 Committee SQL Generator ===")
    
    # Find the most recent data file
    import glob
    data_files = glob.glob("aggressive_815_expansion_*.json")
    if not data_files:
        print("ERROR: No expansion data file found.")
        return False
    
    latest_file = sorted(data_files)[-1]
    print(f"Using data file: {latest_file}")
    print("=" * 50)
    
    generator = CorrectedSQLGenerator(latest_file)
    
    if not generator.load_committee_data():
        return False
    
    if not generator.generate_deployment_sql():
        return False
    
    sql_file = generator.save_sql_file()
    
    print("\n" + "=" * 50)
    print("CORRECTED SQL GENERATION COMPLETE!")
    print(f"SQL file: {sql_file}")
    print("=" * 50)
    
    return True

if __name__ == "__main__":
    main()